C51 COMPILER V9.55   I2C                                                                   12/09/2020 20:35:56 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\I2C.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Listings\I2C\I2C.C OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Listings\I2C;.\List
                    -ings\MAIN;.\Listings\RDA5807) DEBUG OBJECTEXTEND PRINT(.\Listings\I2C.lst) OBJECT(.\Objects\I2C.obj)

line level    source

   1          //Ó°Òþ½Ù£¨ZGT£©
   2          #include <I2C.h>
   3          /*******************************************************************************
   4          * º¯ÊýÃû         :delay_5us()
   5          * º¯Êý¹¦ÄÜ       :ÑÓÊ±5usÓÃÓÚÊÊÓ¦I2CÖÐ¸÷ÖÖÑÓÊ±µÄÐèÇó
   6          * ÊäÈë           :ÎÞ
   7          * Êä³ö           :ÎÞ
   8          *******************************************************************************/
   9          void delay_5us(void)
  10          {
  11   1              #if Main_Fosc == 11059200       
  12   1                       _nop_();       //ÕâÀïÖ»²ÉÓÃÒ»¸ö_nop_Ö¸ÁîÊÇÒòÎª½øÈëºÍÍË³ö¸Ãº¯ÊýÐèÒª2¸ö»úÆ÷ÖÜÆÚ
  13   1                                              //ÔÙÖ´ÐÐÒ»¸ö»úÆ÷ÖÜÆÚÇ¡ºÃ5¸ö5us¶àÒ»µã±Ï¾¹ÓÐµãÎó²î
  14   1              #elif Main_Fosc == 12000000
                              _nop_();
                      #elif Main_Fosc == 22118400
                              _nop_();_nop_();_nop_();
                      #endif
  19   1      }
  20          
  21          /*******************************************************************************
  22          * º¯ÊýÃû         :I2C_Init()
  23          * º¯Êý¹¦ÄÜ       :ÉèÖÃI2C´®¿Ú
  24          * ÊäÈë           :ÎÞ
  25          * Êä³ö           :ÎÞ
  26          *******************************************************************************/
  27          void I2C_Init(void)
  28          {
  29   1              SDA = 1;
  30   1              _nop_();                        //½øÐÐÐ¡µÄÑÓÊ±µÈ´ýµçÑ¹ÎÈ¶¨ÏÂÍ¬
  31   1              SCL = 1;
  32   1              _nop_();
  33   1      }
  34          /*******************************************************************************
  35          * º¯ÊýÃû         :I2C_Start()
  36          * º¯Êý¹¦ÄÜ       :·¢ËÍÒ»¸öÆðÊ¼ÐÅºÅ
  37          * ÊäÈë           :ÎÞ
  38          * Êä³ö           :ÎÞ
  39          *******************************************************************************/
  40          void I2C_Start(void)
  41          {
  42   1              SCL = 1;
  43   1              _nop_();
  44   1              SDA = 1;
  45   1              delay_5us();    
  46   1              //·¢ËÍÆðÊ¼ÐÅºÅÇ°Á½Ìõ×ÜÏßµÄ¸ßµçÆ½ÒªÏÈ³ÖÐø>4.7usµÄÊ±¼ä
  47   1              SDA = 0;
  48   1              delay_5us();
  49   1              //È»ºó½«SDAÀ­µÍ>4usµÄÊ±¼ä¾ÍÏàµ±ÓÚ·¢ËÍÁËÒ»¸öÆðÊ¼ÐÅºÅ
  50   1      }
  51          /*******************************************************************************
  52          * º¯ÊýÃû         :I2C_Stop()
  53          * º¯Êý¹¦ÄÜ       :·¢ËÍÒ»¸öÆðÊ¼ÐÅºÅ
  54          * ÊäÈë           :ÎÞ
C51 COMPILER V9.55   I2C                                                                   12/09/2020 20:35:56 PAGE 2   

  55          * Êä³ö           :ÎÞ
  56          *******************************************************************************/
  57          void I2C_Stop(void)
  58          {
  59   1              SDA = 0;
  60   1              _nop_();
  61   1              SCL = 1;
  62   1              delay_5us();    
  63   1              //·¢ËÍÖÕÖ¹ÐÅºÅÇ°SCLÎª¸ßSDAÎªµÍÏÈ³ÖÐø>4.7usµÄÊ±¼ä
  64   1              SDA = 1;
  65   1              delay_5us();
  66   1              //È»ºó½«SDAÀ­¸ß>4usµÄÊ±¼ä¾ÍÏàµ±ÓÚ·¢ËÍÁËÒ»¸öÆðÊ¼ÐÅºÅ
  67   1      }
  68          /*******************************************************************************
  69          * º¯ÊýÃû         :Master_ACK(bit i)
  70          * º¯Êý¹¦ÄÜ       :Ö÷»úÏò´Ó»ú·¢ËÍÒ»¸öÓ¦´ðÐÅºÅ
  71          * ÊäÈë           :1Ó¦´ð£»0·ÇÓ¦´ð
  72          * Êä³ö           :ÎÞ
  73          *******************************************************************************/
  74          void Master_ACK(bit i)
  75          {
  76   1         SCL = 0;
  77   1         _nop_();
  78   1         //Ö»ÓÐÊ±ÖÓ×ÜÏßÎªµÍÊ±²ÅÔÊÐíSDAÊý¾Ý×ÜÏß±ä»¯
  79   1         if(i)//ÊäÈëÖµÎª1±íÊ¾·¢ËÍÓ¦´ðÐÅºÅÀ­µÍÊý¾Ý×ÜÏß£¬·ñÔò·¢ËÍ·ÇÓ¦´ðÀ­¸ßÊý¾Ý×ÜÏß
  80   1         {
  81   2                      SDA = 0;
  82   2         }
  83   1         else
  84   1         {
  85   2                      SDA = 1;
  86   2         }
  87   1         _nop_();
  88   1         SCL = 1;
  89   1         //½«SCLÀ­¸ßSDAÊý¾Ý²Å»á±»¶Á×ß
  90   1         delay_5us();//Ó¦´ðÐÅºÅÐèÒª±£³ÖÊ±¼ä>4us
  91   1         SCL = 0;
  92   1         _nop_();
  93   1         //½«SCLÖØÐÂÀ­µÍ£¬Õ¼ÓÃ×ÜÏß¼ÌÐøÍ¨ÐÅ£¨ÒòÎªÊ±ÖÓ×ÜÏßÀ­µÍÁËSDA²ÅÔÊÐí±ä»¯£©
  94   1         SDA = 1;
  95   1         _nop_();
  96   1         //ÊÍ·ÅSDAÏß£¬²»ÓÃÊ±¶¼ÒªÊÍ·ÅÀ­¸ß
  97   1      }
  98          /*******************************************************************************
  99          * º¯ÊýÃû         :Test_ACK()
 100          * º¯Êý¹¦ÄÜ       :¼ì²â´Ó»úÊÇ·ñÓ¦´ð
 101          * ÊäÈë           :ÎÞ
 102          * Êä³ö           :1·ÇÓ¦´ð£»0Ó¦´ð
 103          *******************************************************************************/
 104          bit Test_ACK(void)
 105          {
 106   1              SCL = 1;
 107   1              delay_5us();
 108   1              if(SDA)//SDAÎª¸ßËµÃ÷´Ó»ú·ÇÓ¦´ð·¢ËÍÍ£Ö¹ÐÅºÅ·µ»Ø0£»·ñÔò·µ»Ø1
 109   1              {
 110   2                      SCL = 0;
 111   2                      _nop_();
 112   2                      I2C_Stop();
 113   2                      return (0);
 114   2              }
 115   1              else
 116   1              {
C51 COMPILER V9.55   I2C                                                                   12/09/2020 20:35:56 PAGE 3   

 117   2                      SCL = 0;
 118   2                      _nop_();
 119   2                      return (1);
 120   2              }
 121   1      }
 122          /*******************************************************************************
 123          * º¯ÊýÃû         :I2C_Send_Byte(uchar byte)
 124          * º¯Êý¹¦ÄÜ       :Ö÷»ú·¢ËÍÒ»¸ö×Ö½Ú
 125          * ÊäÈë           :ÐèÒª·¢ËÍµÄ×Ö½Ú
 126          * Êä³ö           :ÎÞ
 127          *******************************************************************************/
 128          void I2C_Send_Byte(unsigned char byte)
 129          {
 130   1              unsigned char i;
 131   1              for(i = 0;i < 8;i++)
 132   1              {
 133   2                      SCL = 0;
 134   2                      _nop_();
 135   2                      if(byte & 0x80)//ÓÉÓÚI2CµÄ´«ÊäÊÇ´Ó×î¸ßÎ»¿ªÊ¼µÄ¶øÇÒÊÇ8Î»Òò´ËÓÃ0x80ÅÐ¶Ï
 136   2                      {
 137   3                              SDA = 1;
 138   3                              _nop_();
 139   3                      }
 140   2                      else
 141   2                      {
 142   3                              SDA = 0;
 143   3                              _nop_();
 144   3                      }
 145   2                      SCL = 1;                //SCLÖÃ¸ßÊý¾Ý²ÅÄÜ±»¶Á³ö
 146   2                      _nop_();
 147   2                      byte <<= 1;             //Ã¿´Î×óÒÆÒ»Î»Ñ­»·8´Î¾Í½«Ò»¸ö×Ö½Ú·¢ËÍ³öÈ¥ÁË
 148   2              }
 149   1              SCL = 0;
 150   1              _nop_();
 151   1              SDA = 1;
 152   1              _nop_();
 153   1      }
 154          /*******************************************************************************
 155          * º¯ÊýÃû         :I2C_Read_Byte()
 156          * º¯Êý¹¦ÄÜ       :Ö÷»úÍ¨¹ýI2C¶ÁÈ¡Ò»¸ö×Ö½Ú
 157          * ÊäÈë           :ÎÞ
 158          * Êä³ö           :¶ÁÈ¡µ½µÄ×Ö½Ú
 159          *******************************************************************************/
 160          unsigned char I2C_Read_Byte(void)
 161          {
 162   1         unsigned char Read_Data;
 163   1         unsigned char i;
 164   1         SCL = 0;
 165   1         _nop_();
 166   1         SDA = 1;
 167   1         _nop_();
 168   1         for(i = 0;i < 8;i++)
 169   1         {
 170   2                      SCL = 1;
 171   2                      _nop_();
 172   2                      if(SDA)//ÒòÎªÎÒÃÇ²ÉÈ¡µÄÊÇ×óÒÆµÄ·½·¨Òò´ËÊÇ´Ó×îµÍÎ»¿ªÊ¼Ð´Êý¾ÝÒÆÏò×î¸ßÎ»¾ÍÓÃÒÔÏÂ´úÂë
 173   2                      {
 174   3                              Read_Data |= 0x01;
 175   3                      }
 176   2                      else
 177   2                      {
 178   3                              Read_Data &= 0xfe;
C51 COMPILER V9.55   I2C                                                                   12/09/2020 20:35:56 PAGE 4   

 179   3                      }
 180   2                      _nop_();
 181   2                      SCL = 0;
 182   2                      _nop_();
 183   2                      if(i < 7)//Ñ­»·µÄ×îºóÒ»´Î²»ÄÜÒÆÎ»£¬×îºóÒ»´Î»¹ÒÆÎ»»á°Ñ×î¸ßÎ»Êý¾ÝÒÆ³ý
 184   2                      {       Read_Data = Read_Data << 1;     }
 185   2         }
 186   1         return (Read_Data);
 187   1      }                               
 188          /*******************************************************************************
 189          * º¯ÊýÃû         :I2C_TransmitData(uchar Slave_ADDR,ADDR,DATA)
 190          * º¯Êý¹¦ÄÜ       :Ö÷»ú·¢ËÍÒ»¸ö×Ö½Úµ½ÌØ¶¨µÄµØÖ·
 191          * ÊäÈë           :Slave_ADDR´ÓÉè±¸µÄµØÖ·£¬ADDR´ÓÉè±¸µÄ´æ´¢µØÖ·£¬DATAÐèÒª·¢ËÍµÄÊý¾Ý
 192          * Êä³ö           :´Ó»úÊÇ·ñÓ¦´ð0·ÇÓ¦´ð£¬1Ó¦´ð
 193          *******************************************************************************/
 194          //bit I2C_TransmitData(unsigned char Slave_ADDR,ADDR,DATA)
 195          //{
 196          //      //Ð´×Ö½Úµ½AT24C02
 197          //      I2C_Start();
 198          //      I2C_Send_Byte(Slave_ADDR);      //Ð´ÈëÐèÒªÐ´µÄÆ÷¼þµØÖ·
 199          //      if(!Test_ACK())                         //µÈ´ýÓ¦´ð
 200          //      {       return (0);     }
 201          //      I2C_Send_Byte(ADDR);            //´Ó¸ÃµØÖ·¿ªÊ¼Ð´
 202          //      if(!Test_ACK())
 203          //      {       return (0);     }
 204          //      I2C_Send_Byte(DATA);            //Ð´ÈëÊý¾Ý
 205          //      if(!Test_ACK())
 206          //      {       return (0);     }
 207          //      I2C_Stop();
 208          //      return (1);
 209          //}
 210          /*******************************************************************************
 211          * º¯ÊýÃû         :I2C_ReceiveData(uchar Slave_ADDR,ADDR)
 212          * º¯Êý¹¦ÄÜ       :Ö÷»ú½ÓÊÕÒ»¸öÌØ¶¨µØÖ·µÄ×Ö½Ú
 213          * ÊäÈë           :Slave_ADDR´ÓÉè±¸µÄµØÖ·,ADDR´ÓÉè±¸µÄ´æ´¢µ¥ÔªµØÖ·
 214          * Êä³ö           :¶Áµ½µÄÊý¾ÝRead_DataÒÔÎÞ·ûºÅ×Ö·ûÐÍÊä³ö;0ÓÐ¿ÉÄÜ½ÓÊÕÃ»±»Ó¦´ð
 215          *******************************************************************************/
 216          //unsigned char I2C_ReceiveData(unsigned char Slave_ADDR,ADDR)
 217          //{
 218          //      //¶ÁAT24C02µÄ×Ö½Ú
 219          //      unsigned char Read_Data;
 220          //      I2C_Start();
 221          //      I2C_Send_Byte(Slave_ADDR);              //Ð´ÈëÐèÒª¶ÁµÄÆ÷¼þµØÖ·
 222          //      if(!Test_ACK())                                 //µÈ´ýÓ¦´ð
 223          //      {       return (0);     }
 224          //      I2C_Send_Byte(ADDR);                    //´Ó¸ÃµØÖ·¿ªÊ¼¶Á          
 225          //      Master_ACK(0);
 226          //      I2C_Start();
 227          //      I2C_Send_Byte(Slave_ADDR + 1);  //Ð´ÈëÐèÒª¶ÁµÄÆ÷¼þµØÖ·£¬ÕâÀï+1ÊÇÒòÎªI2CµÄ×îºóÒ»Î»¿ØÖÆ¶ÁÐ´£¬Îª0ÊÇÐ´Îª1ÊÇ¶
             -Á
 228          //      if(!Test_ACK())                                 //µÈ´ýÓ¦´ð
 229          //      {       return (0);     }
 230          //      Read_Data = I2C_Read_Byte();
 231          //      Master_ACK(0);
 232          //      I2C_Stop();
 233          //      return (Read_Data);
 234          //}
 235          /*******************************************************************************
 236          * º¯ÊýÃû         :I2C_ReceiveData(uchar Slave_ADDR,ADDR)
 237          * º¯Êý¹¦ÄÜ       :Ö÷»ú½ÓÊÕÒ»¸öÌØ¶¨µØÖ·µÄ×Ö½Ú
 238          * ÊäÈë           :Slave_ADDR´ÓÉè±¸µÄµØÖ·,ADDR´ÓÉè±¸µÄ´æ´¢µ¥ÔªµØÖ·
 239          * Êä³ö           :¶Áµ½µÄÊý¾ÝRead_Data²¢ÒÔÕûÐÎÐÎÊ½Êä³ö;0ÓÐ¿ÉÄÜ½ÓÊÕÃ»±»Ó¦´ð
C51 COMPILER V9.55   I2C                                                                   12/09/2020 20:35:56 PAGE 5   

 240          *******************************************************************************/
 241          //int I2C_ReceiveData1(unsigned char Slave_ADDR,ADDR)
 242          //{
 243          //      //¶ÁAT24C02µÄ×Ö½Ú
 244          //      unsigned int Read_Data;
 245          //      I2C_Start();
 246          //      I2C_Send_Byte(Slave_ADDR);              //Ð´ÈëÐèÒª¶ÁµÄÆ÷¼þµØÖ·
 247          //      if(!Test_ACK())                                 //µÈ´ýÓ¦´ð
 248          //      {       return (0);     }
 249          //      I2C_Send_Byte(ADDR);                    //´Ó¸ÃµØÖ·¿ªÊ¼¶Á          
 250          //      Master_ACK(0);
 251          //      I2C_Start();
 252          //      I2C_Send_Byte(Slave_ADDR + 1);  //Ð´ÈëÐèÒª¶ÁµÄÆ÷¼þµØÖ·£¬ÕâÀï+1ÊÇÒòÎªI2CµÄ×îºóÒ»Î»¿ØÖÆ¶ÁÐ´£¬Îª0ÊÇÐ´Îª1ÊÇ¶
             -Á
 253          //      if(!Test_ACK())                                 //µÈ´ýÓ¦´ð
 254          //      {       return (0);     }
 255          //      Read_Data = I2C_Read_Byte();
 256          //      Master_ACK(0);
 257          //      I2C_Stop();
 258          //      return (Read_Data);
 259          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    157    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
